{"ast":null,"code":"const contentHasMatch = filterBy => {\n  filterBy = filterBy.toLowerCase();\n  return ({\n    title,\n    overview\n  }) => {\n    const foundInTitle = title.toLowerCase().indexOf(filterBy) > -1;\n    const foundInOverview = overview.toLowerCase().indexOf(filterBy) > -1;\n    return !filterBy ? true : foundInTitle || foundInOverview;\n  };\n};\n// Create a filter function\nexport function computeFilteredMovies({\n  allMovies,\n  filterBy\n}) {\n  const hasMatches = contentHasMatch(filterBy);\n  return allMovies.filter(hasMatches).map(m => ({\n    ...m\n  }));\n}\n/**\n * For the specified filter, find all matches in all movie overviews\n */\nexport const buildMatchIndicator = filterBy => source => {\n  const matchIn = s => filterBy ? s.replace(new RegExp(filterBy, 'gi'), match => `<span class='match'>${match}</span>`) : s;\n  return source.map(m => ({\n    ...m,\n    title: matchIn(m.title),\n    overview: matchIn(m.overview)\n  }));\n};\n/**\n * Why are computed properties valuable, calculated on-demand\n * and NOT serialized.\n */\nexport function computeMatchedMovies(state) {\n  const movies = computeFilteredMovies(state);\n  const addMatchIndicators = buildMatchIndicator(state.filterBy);\n  return addMatchIndicators(movies);\n}","map":{"version":3,"mappings":"AAEA,MAAMA,eAAe,GAAIC,QAAgB,IAAI;EAC3CA,QAAQ,GAAGA,QAAQ,CAACC,WAAW,EAAE;EACjC,OAAO,CAAC;IAAEC,KAAK;IAAEC;EAAQ,CAAa,KAAI;IACxC,MAAMC,YAAY,GAAGF,KAAK,CAACD,WAAW,EAAE,CAACI,OAAO,CAACL,QAAQ,CAAC,GAAG,CAAC,CAAC;IAC/D,MAAMM,eAAe,GAAGH,QAAQ,CAACF,WAAW,EAAE,CAACI,OAAO,CAACL,QAAQ,CAAC,GAAG,CAAC,CAAC;IAErE,OAAO,CAACA,QAAQ,GAAG,IAAI,GAAGI,YAAY,IAAIE,eAAe;EAC3D,CAAC;AACH,CAAC;AAED;AACA,OAAM,SAAUC,qBAAqB,CAAC;EACpCC,SAAS;EACTR;AAAQ,CACY;EACpB,MAAMS,UAAU,GAAGV,eAAe,CAACC,QAAQ,CAAC;EAC5C,OAAOQ,SAAS,CAACE,MAAM,CAACD,UAAU,CAAC,CAACE,GAAG,CAAEC,CAAC,KAAM;IAAE,GAAGA;EAAC,CAAE,CAAC,CAAC;AAC5D;AAEA;;;AAGA,OAAO,MAAMC,mBAAmB,GAC7Bb,QAA4B,IAC5Bc,MAAmB,IAAiB;EACnC,MAAMC,OAAO,GAAIC,CAAS,IACxBhB,QAAQ,GACJgB,CAAC,CAACC,OAAO,CACP,IAAIC,MAAM,CAAClB,QAAQ,EAAE,IAAI,CAAC,EACzBmB,KAAK,IAAK,uBAAuBA,KAAK,SAAS,CACjD,GACDH,CAAC;EAEP,OAAOF,MAAM,CAACH,GAAG,CAAEC,CAAC,KAAM;IACxB,GAAGA,CAAC;IACJV,KAAK,EAAEa,OAAO,CAACH,CAAC,CAACV,KAAK,CAAC;IACvBC,QAAQ,EAAEY,OAAO,CAACH,CAAC,CAACT,QAAQ;GAC7B,CAAC,CAAC;AACL,CAAC;AAEH;;;;AAIA,OAAM,SAAUiB,oBAAoB,CAACC,KAA0B;EAC7D,MAAMC,MAAM,GAAGf,qBAAqB,CAACc,KAAK,CAAC;EAC3C,MAAME,kBAAkB,GAAGV,mBAAmB,CAACQ,KAAK,CAACrB,QAAQ,CAAC;EAE9D,OAAOuB,kBAAkB,CAACD,MAAM,CAAC;AACnC","names":["contentHasMatch","filterBy","toLowerCase","title","overview","foundInTitle","indexOf","foundInOverview","computeFilteredMovies","allMovies","hasMatches","filter","map","m","buildMatchIndicator","source","matchIn","s","replace","RegExp","match","computeMatchedMovies","state","movies","addMatchIndicators"],"sourceRoot":"","sources":["/project/zustand-angular-movie-search/src/app/data-access/movies/movies.filters.ts"],"sourcesContent":["import { MovieState, MovieItem } from './movies.model';\n\nconst contentHasMatch = (filterBy: string) => {\n  filterBy = filterBy.toLowerCase();\n  return ({ title, overview }: MovieItem) => {\n    const foundInTitle = title.toLowerCase().indexOf(filterBy) > -1;\n    const foundInOverview = overview.toLowerCase().indexOf(filterBy) > -1;\n\n    return !filterBy ? true : foundInTitle || foundInOverview;\n  };\n};\n\n// Create a filter function\nexport function computeFilteredMovies({\n  allMovies,\n  filterBy,\n}: Partial<MovieState>): MovieItem[] {\n  const hasMatches = contentHasMatch(filterBy);\n  return allMovies.filter(hasMatches).map((m) => ({ ...m }));\n}\n\n/**\n * For the specified filter, find all matches in all movie overviews\n */\nexport const buildMatchIndicator =\n  (filterBy: string | undefined) =>\n  (source: MovieItem[]): MovieItem[] => {\n    const matchIn = (s: string) =>\n      filterBy\n        ? s.replace(\n            new RegExp(filterBy, 'gi'),\n            (match) => `<span class='match'>${match}</span>`\n          )\n        : s;\n\n    return source.map((m) => ({\n      ...m,\n      title: matchIn(m.title),\n      overview: matchIn(m.overview),\n    }));\n  };\n\n/**\n * Why are computed properties valuable, calculated on-demand\n * and NOT serialized.\n */\nexport function computeMatchedMovies(state: Partial<MovieState>): MovieItem[] {\n  const movies = computeFilteredMovies(state);\n  const addMatchIndicators = buildMatchIndicator(state.filterBy);\n\n  return addMatchIndicators(movies);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}